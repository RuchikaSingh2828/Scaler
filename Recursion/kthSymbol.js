// Q1. Kth Symbol - Hard

// Problem Description

// On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.

// Given row number A and index B, return the Bth indexed symbol in row A. (The values of B are 0-indexed.).

// Problem Constraints

// 1 <= A <= 105

// 0 <= B <= min(2A - 1 - 1 , 1018)

// Input Format

// First argument is an integer A.

// Second argument is an integer B.

// Output Format

// Return an integer denoting the Bth indexed symbol in row A.

// Example Input

// Input 1:

//  A = 3
//  B = 0
// Input 2:

//  A = 4
//  B = 4

// Example Output

// Output 1:

//  0
// Output 2:

//  1

// Example Explanation

// Explanation 1:

//  Row 1: 0
//  Row 2: 01
//  Row 3: 0110
// Explanation 2:

//  Row 1: 0
//  Row 2: 01
//  Row 3: 0110
//  Row 4: 01101001

//! Hint :

// A = 1 -> 0
// A = 2 ->01
// A = 3 ->0110

// As we can see that there are two part in string (when A>=2)
// first part is repeating of (A-1)th> step and second part is also compliment of (A-1)th step

// When
// A = 1 -> 0
// A = 2 ->01
// A = 3 ->0110

// As we can see that there are two part in string (when A>=2)
// first part is repeating of (A-1)th> step and second part is also compliment of (A-1)th step

// for A = 3 -> first part - 01 ( it is same as when A == 2) second part- 10 ( compliment of when A == 2)

// We know that on every expansion, the length of String is 2(A-1)

// so what we can do when B value is <= mid we can search the result in first part of (A-1)th step solve(A-1, B)

// and when B > mid we can search the result in (A-1)th step but compliment of that index to get the actual index in 1st part we have to do B - mid.
// This problem follows a recursive pattern based on the transformation rules:

// 1. Row 1: **0**
// 2. Row 2: **01**
// 3. Row 3: **0110**
// 4. Row 4: **01101001**

// Each row is generated by replacing:
// - `0` â†’ `01`
// - `1` â†’ `10`

// ### Observations:
// 1. The length of row ( A ) is ( 2^{(A-1)} ).
// 2. The value at index ( B ) in row ( A ) depends on the value at index ( B/2 ) in the previous row.
// 3. Specifically:
//    - If ( B ) is even, the symbol is the same as in the previous row at index ( B/2 ).
//    - If ( B ) is odd, the symbol is the complement (flipped) of the previous row at index ( B/2 ).

// ### Recursive Approach:
// - Base Case: If ( A = 1 ), return `0`.
// - Recursive Case: Find the parent symbol in the previous row and determine whether to flip it.

// ### Code Implementation:
// ```python
// def kth_symbol(A, B):
//     if A == 1:
//         return 0  # Base case

//     parent = kth_symbol(A - 1, B // 2)  # Find the parent symbol
//     return parent if B % 2 == 0 else 1 - parent  # Flip if B is odd

// # Example Cases
// print(kth_symbol(3, 0))  # Output: 0
// print(kth_symbol(4, 4))  # Output: 1
// ```

// ### Complexity Analysis:
// - Since we are reducing ( A ) by 1 in each step, the depth of recursion is ( O(log B) ).
// - This is efficient given the constraints (up to ( 10^{18} ) for ( B )).

// Would you like an iterative approach instead to avoid recursion? ðŸš€
// https://chatgpt.com/c/679e156f-430c-8001-8eed-f3328264eed6#:~:text=This%20problem%20follows,to%20flip%20it.
const kthSymbol = (A, B) => {
  B = BigInt(B);
  if (A === 1) return 0;
  const parent = kthSymbol(A - 1, B / 2n);
  return B % 2n === 0n ? parent : 1 - parent;
  // if (A === 0) return '0';
  // const num = kthSymbol(A - 1, B );
  // const len = num.length;
  // if (len > B) {
  //   const result = num.split('');
  //   return result[B];
  // }
  // let compliment = num
  //   .split('')
  //   .map((bit) => (bit === '0' ? '1' : '0'))
  //   .join('');
  // if (2 * len < B) {
  //   return num + compliment;
  // }
  // let positionInCompliment = B - len;
  // const result = compliment.split('');
  // return result[positionInCompliment];
};

console.log(kthSymbol(4, 6)); // 0
console.log(kthSymbol(277, 887)); // 0
console.log(kthSymbol(39866, 479540875878896909)); // 0
